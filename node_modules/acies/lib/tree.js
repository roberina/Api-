"use strict";
exports.__esModule = true;
var box_1 = require("./box");
var hit_1 = require("./hit");
var axis_1 = require("./axis");
var math_1 = require("./math");
var Tree = /** @class */ (function () {
    function Tree(shapes) {
        this.box = box_1.boxForShapes(shapes);
        var node = new Node(shapes);
        node.split(0);
        this.root = node;
    }
    Tree.prototype.intersect = function (r) {
        var _a = this.box.intersect(r), tmin = _a[0], tmax = _a[1];
        if (tmax < tmin || tmax <= 0) {
            return hit_1.NoHit;
        }
        var h = this.root.intersect(r, tmin, tmax);
        return h;
    };
    return Tree;
}());
exports.Tree = Tree;
var Node = /** @class */ (function () {
    function Node(shapes) {
        this.axis = axis_1.Axis.AxisNone;
        this.point = 0;
        this.shapes = shapes;
        left: null;
        right: null;
    }
    Node.prototype.intersect = function (r, tmin, tmax) {
        var tsplit;
        var leftFirst;
        switch (this.axis) {
            case axis_1.Axis.AxisNone:
                return this.intersectShapes(r);
            case axis_1.Axis.AxisX:
                tsplit = (this.point - r.origin.x) / r.direction.x;
                leftFirst =
                    r.origin.x < this.point ||
                        (r.origin.x == this.point && r.direction.x <= 0);
                break;
            case axis_1.Axis.AxisY:
                tsplit = (this.point - r.origin.y) / r.direction.y;
                leftFirst =
                    r.origin.y < this.point ||
                        (r.origin.y == this.point && r.direction.y <= 0);
                break;
            case axis_1.Axis.AxisZ:
                tsplit = (this.point - r.origin.z) / r.direction.z;
                leftFirst =
                    r.origin.z < this.point ||
                        (r.origin.z == this.point && r.direction.z <= 0);
                break;
        }
        var first;
        var second;
        if (leftFirst) {
            first = this.left;
            second = this.right;
        }
        else {
            first = this.right;
            second = this.left;
        }
        if (tsplit > tmax || tsplit <= 0) {
            return first.intersect(r, tmin, tmax);
        }
        else if (tsplit < tmin) {
            return second.intersect(r, tmin, tmax);
        }
        else {
            var h1 = first.intersect(r, tmin, tsplit);
            if (h1.t <= tsplit) {
                return h1;
            }
            var h2 = second.intersect(r, tsplit, Math.min(tmax, h1.t));
            if (h1.t <= h2.t) {
                return h1;
            }
            else {
                return h2;
            }
        }
    };
    Node.prototype.intersectShapes = function (r) {
        var hit = hit_1.NoHit;
        for (var _i = 0, _a = this.shapes; _i < _a.length; _i++) {
            var shape = _a[_i];
            var h = shape.intersect(r);
            if (h.t < hit.t) {
                hit = h;
            }
        }
        return hit;
    };
    Node.prototype.partitionScore = function (axis, point) {
        var left = 0;
        var right = 0;
        for (var _i = 0, _a = this.shapes; _i < _a.length; _i++) {
            var shape = _a[_i];
            var box = shape.boundingBox();
            var _b = box.partition(axis, point), l = _b[0], r = _b[1];
            if (l) {
                left++;
            }
            if (r) {
                right++;
            }
        }
        if (left >= right) {
            return left;
        }
        else {
            return right;
        }
    };
    Node.prototype.partition = function (size, axis, point) {
        var left = [];
        var right = [];
        for (var _i = 0, _a = this.shapes; _i < _a.length; _i++) {
            var shape = _a[_i];
            var box = shape.boundingBox();
            var _b = box.partition(axis, point), l = _b[0], r = _b[1];
            if (l) {
                left.push(shape);
            }
            if (r) {
                right.push(shape);
            }
        }
        return [left, right];
    };
    Node.prototype.split = function (depth) {
        if (this.shapes.length < 8) {
            return;
        }
        var xs = new Float64Array(this.shapes.length * 2);
        var ys = new Float64Array(this.shapes.length * 2);
        var zs = new Float64Array(this.shapes.length * 2);
        var xi = 0;
        var yi = 0;
        var zi = 0;
        for (var _i = 0, _a = this.shapes; _i < _a.length; _i++) {
            var shape = _a[_i];
            var box = shape.boundingBox();
            xs[xi++] = box.min.x;
            xs[xi++] = box.max.x;
            ys[yi++] = box.min.y;
            ys[yi++] = box.max.y;
            zs[zi++] = box.min.z;
            zs[zi++] = box.max.z;
        }
        xs.sort();
        ys.sort();
        zs.sort();
        var mx = math_1.median(xs);
        var my = math_1.median(ys);
        var mz = math_1.median(zs);
        var best = (this.shapes.length * 0.85) | 0;
        var bestAxis = axis_1.Axis.AxisNone;
        var bestPoint = 0.0;
        var sx = this.partitionScore(axis_1.Axis.AxisX, mx);
        if (sx < best) {
            best = sx;
            bestAxis = axis_1.Axis.AxisX;
            bestPoint = mx;
        }
        var sy = this.partitionScore(axis_1.Axis.AxisY, my);
        if (sy < best) {
            best = sy;
            bestAxis = axis_1.Axis.AxisY;
            bestPoint = my;
        }
        var sz = this.partitionScore(axis_1.Axis.AxisZ, mz);
        if (sz < best) {
            best = sz;
            bestAxis = axis_1.Axis.AxisZ;
            bestPoint = mz;
        }
        if (bestAxis === axis_1.Axis.AxisNone) {
            return;
        }
        var _b = this.partition(best, bestAxis, bestPoint), l = _b[0], r = _b[1];
        this.axis = bestAxis;
        this.point = bestPoint;
        this.left = new Node(l);
        this.right = new Node(r);
        this.left.split(depth + 1);
        this.right.split(depth + 1);
        this.shapes = null;
    };
    return Node;
}());
exports.Node = Node;
