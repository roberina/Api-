"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var vector_1 = require("./vector");
var box_1 = require("./box");
var hit_1 = require("./hit");
var math_1 = require("./math");
var Sphere = /** @class */ (function () {
    function Sphere(center, radius) {
        var min = new vector_1["default"](center.x - radius, center.y - radius, center.z - radius);
        var max = new vector_1["default"](center.x + radius, center.y + radius, center.z + radius);
        var box = new box_1.Box(min, max);
        this.center = center;
        this.box = box;
        this.radius = radius;
    }
    Sphere.prototype.compile = function () {
        // Noop
    };
    Sphere.prototype.boundingBox = function () {
        return this.box;
    };
    Sphere.prototype.contains = function (v, f) {
        return v.sub(this.center).length() <= this.radius + f;
    };
    Sphere.prototype.intersect = function (r) {
        var radius = this.radius;
        var to = r.origin.sub(this.center);
        var b = to.dot(r.direction);
        var c = to.dot(to) - radius * radius;
        var d = b * b - c;
        if (d > 0) {
            d = Math.sqrt(d);
            var t1 = -b - d;
            if (t1 > 1e-2) {
                return new hit_1["default"](this, t1);
            }
            var t2 = -b + d;
            if (t2 > 1e-2) {
                return new hit_1["default"](this, t2);
            }
        }
        return hit_1.NoHit;
    };
    Sphere.prototype.paths = function () {
        var paths = [];
        var n = 10;
        var o = 10;
        for (var lat = -90 + o; lat <= 90 - o; lat += n) {
            var path = [];
            for (var lng = 0; lng <= 360; lng++) {
                var v = latLngToXYZ(lat, lng, this.radius).add(this.center);
                path.push(v);
            }
            paths.push(path);
        }
        for (var lng = 0; lng <= 360; lng += n) {
            var path = [];
            for (var lat = -90 + o; lat <= 90 - o; lat++) {
                var v = latLngToXYZ(lat, lng, this.radius).add(this.center);
                path.push(v);
            }
            paths.push(path);
        }
        return paths;
    };
    return Sphere;
}());
exports.Sphere = Sphere;
var OutlineSphere = /** @class */ (function (_super) {
    __extends(OutlineSphere, _super);
    function OutlineSphere(eye, up, center, radius) {
        var _this = _super.call(this, center, radius) || this;
        _this.up = up;
        _this.eye = eye;
        return _this;
    }
    OutlineSphere.prototype.paths = function () {
        var path = [];
        var center = this.center;
        var radius = this.radius;
        var hyp = center.sub(this.eye).length();
        var opp = radius;
        var theta = Math.asin(opp / hyp);
        var adj = opp / Math.tan(theta);
        var d = Math.cos(theta) * adj;
        var r = Math.sin(theta) * adj;
        var w = center.sub(this.eye).normalize();
        var u = w.cross(this.up).normalize();
        var v = w.cross(u).normalize();
        var c = this.eye.add(w.multiplyScalar(d));
        for (var i = 0; i <= 360; i++) {
            var a = math_1.radians(i);
            var p = c;
            p = p.add(u.multiplyScalar(Math.cos(a) * r));
            p = p.add(v.multiplyScalar(Math.sin(a) * r));
            path.push(p);
        }
        return [path];
    };
    return OutlineSphere;
}(Sphere));
exports.OutlineSphere = OutlineSphere;
function latLngToXYZ(lat, lng, radius) {
    var latr = math_1.radians(lat);
    var lngr = math_1.radians(lng);
    var x = radius * Math.cos(latr) * Math.cos(lngr);
    var y = radius * Math.cos(latr) * Math.sin(lngr);
    var z = radius * Math.sin(latr);
    return new vector_1["default"](x, y, z);
}
