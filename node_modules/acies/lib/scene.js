"use strict";
exports.__esModule = true;
var tree_1 = require("./tree");
var ray_1 = require("./ray");
var vector_1 = require("./vector");
var Paths = require("./paths");
var matrix_1 = require("./matrix");
var filter_1 = require("./filter");
var Scene = /** @class */ (function () {
    function Scene() {
        this.shapes = [];
        this.tree = null;
    }
    Scene.prototype.compile = function () {
        for (var _i = 0, _a = this.shapes; _i < _a.length; _i++) {
            var shape = _a[_i];
            shape.compile();
        }
        this.tree = new tree_1.Tree(this.shapes);
    };
    Scene.prototype.add = function (shape) {
        this.shapes.push(shape);
    };
    Scene.prototype.intersect = function (ray) {
        return this.tree.intersect(ray);
    };
    Scene.prototype.visible = function (eye, point) {
        var v = eye.sub(point);
        var r = new ray_1["default"](point, v.normalize());
        var hit = this.intersect(r);
        return hit.t >= v.length();
    };
    Scene.prototype.paths = function () {
        var results = [];
        for (var _i = 0, _a = this.shapes; _i < _a.length; _i++) {
            var shape = _a[_i];
            var shapePaths = shape.paths();
            shapePaths.forEach(function (p) { return results.push(p); });
        }
        return results;
    };
    Scene.prototype.render = function (eye, center, up, width, height, fovy, near, far, step) {
        var aspect = width / height;
        var matrix = matrix_1.lookAt(eye, center, up);
        matrix = matrix.perspective(fovy, aspect, near, far);
        return this.renderWithMatrix(matrix, eye, width, height, step);
    };
    Scene.prototype.renderWithMatrix = function (matrix, eye, width, height, step) {
        this.compile();
        var paths = this.paths();
        if (step > 0) {
            paths = Paths.chop(paths, step);
        }
        var f = new filter_1.ClipFilter(matrix, eye, this);
        // We're always filtering the same paths?
        paths = Paths.filterPaths(paths, f);
        if (step > 0) {
            paths = Paths.simplify(paths, 1e-6);
        }
        console.log(paths.length);
        var matrix2 = matrix_1.createTranslateMatrix(new vector_1["default"](1, 1, 0)).scale(new vector_1["default"](width / 2, height / 2, 0));
        return Paths.transform(paths, matrix2);
    };
    return Scene;
}());
exports["default"] = Scene;
